name: CI/CD Calamity Renderer
on:
  workflow_dispatch:
    inputs:
      obj_file_url:
        description: 'URL to a raw .obj file (e.g., a teapot)'
        required: true
        default: 'https://graphics.stanford.edu/courses/cs148-10-summer/as3/code/as3/teapot.obj'
      artistic_seed:
        description: 'A random string. Used for "artistic" choices.'
        required: true
        default: 'chaos'

jobs:
  stage-1-vector-to-pixel:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Download 3D Model
        run: curl -L "${{ github.event.inputs.obj_file_url }}" -o model.obj

      - name: Install Dependencies
        run: sudo apt-get update && sudo apt-get install -y imagemagick

      - name: Parse .obj and convert vertices to a PPM image

        run: |
          python3 -c "
          import sys
          vertices = [l.strip().split(' ')[1:4] for l in open('model.obj') if l.startswith('v ')]
          w = h = int(len(vertices)**0.5) + 1
          img_data = 'P3\n{} {}\n255\n'.format(w, h)
          pixels = []
          for v in vertices:
              # Normalize and map coordinates to 0-255 color values
              x = int((float(v[0]) + 4) * 32) % 256
              y = int((float(v[1]) + 1) * 64) % 256
              z = int((float(v[2]) + 4) * 32) % 256
              pixels.append('{} {} {}'.format(x, y, z))
          # Pad the rest of the image with black pixels
          pixels += ['0 0 0'] * (w * h - len(pixels))
          img_data += '\n'.join(pixels)
          with open('vertex_map.ppm', 'w') as f:
              f.write(img_data)
          "
      - name: Upload artifact
        uses: actions/upload-artifact@v4
        with:
          name: vertex-image
          path: vertex_map.ppm
          
    stage-2-internal-chaos-orientation:
    needs: stage-1-vector-to-pixel
    runs-on: windows-latest
    outputs:
      rotation_angle: ${{ steps.get_orientation.outputs.angle }}
    steps:
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: vertex-image

      - name: Generate Orientation from Internal GitHub Variables
        id: get_orientation
        shell: pwsh
        run: |
          $runId = $env:GITHUB_RUN_ID
          $angle = $runId % 360
          echo "Using Run ID $runId to generate angle: $angle"
          echo "angle=$angle" >> $env:GITHUB_OUTPUT

      - name: Re-convert pixels back to text coordinates
        shell: pwsh
        run: |
          $ppm_content = Get-Content -Path "vertex_map.ppm" -Raw
          $lines = $ppm_content.Split([System.Environment]::NewLine)
          $pixels = $lines[3..($lines.Length-1)] -join ' '
          $coords = @()
          $rgb = $pixels.Split(' ')
          for ($i = 0; $i -lt $rgb.Length; $i += 3) {
              if (($rgb[$i] -eq '0') -and ($rgb[$i+1] -eq '0') -and ($rgb[$i+2] -eq '0')) {
                  continue # Skip padding
              }
              $x = ([double]$rgb[$i] / 32) - 4
              $y = ([double]$rgb[$i+1] / 64) - 1
              $z = ([double]$rgb[$i+2] / 32) - 4
              $coords += "$x $y $z"
          }
          Set-Content -Path "coords.txt" -Value ($coords -join [System.Environment]::NewLine)

      - name: Upload final vertex data
        uses: actions/upload-artifact@v4
        with:
          name: final-vertices
          path: coords.txt
          
  stage-3-live-log-render:
    needs: stage-2-api-driven-orientation
    runs-on: macos-latest
    steps:
      - name: Download final vertex data
        uses: actions/download-artifact@v4
        with:
          name: final-vertices

      - name: Render to ANSI Art in Log
        env:
          ROTATION: ${{ needs.stage-2-api-driven-orientation.outputs.rotation_angle }}
          ART_SEED: ${{ github.event.inputs.artistic_seed }}
        run: |
          ruby -e '
            require "matrix"
            
            ramp = ENV["ART_SEED"].codepoints.uniq.pack("U*").chars
            ramp = ".,-~:;=!*#$@" if ramp.length < 2
            
            coords = File.readlines("coords.txt").map { |l| l.split.map(&:to_f) }
            
            angle = ENV["ROTATION"].to_f * Math::PI / 180
            cos_a, sin_a = Math.cos(angle), Math.sin(angle)
            rot_matrix = Matrix[[cos_a, 0, sin_a], [0, 1, 0], [-sin_a, 0, cos_a]]
            
            width, height = 80, 24
            buffer = Array.new(height) { Array.new(width, " ") }
            z_buffer = Array.new(height) { Array.new(width, -Float::INFINITY) }

            coords.each do |x, y, z|
              v = Vector[x, y, z]
              rotated_v = rot_matrix * v
              
              px = ((rotated_v[0] + 5) * 8).to_i
              py = ((rotated_v[1] + 2) * 6).to_i
              pz = rotated_v[2]
              
              if px >= 0 && px < width && py >= 0 && py < height && pz > z_buffer[py][px]
                z_buffer[py][px] = pz
                depth_index = ((pz + 5) / 10 * (ramp.length - 1)).round.clamp(0, ramp.length - 1)
                buffer[py][px] = ramp[depth_index]
              end
            end
            
            print "\033[2J" # Clear screen
            height.times do |y|
              width.times do |x|
                print "\033[#{y+1};#{x+1}H" # Move cursor
                print "\033[38;5;#{((x+y)*2 + angle.to_i)%255}m" # Ludicrous color
                print buffer[y][x]
                sleep(0.0001)
              end
            end
            puts "\n\nRender complete. A monument to terrible ideas."
          '
